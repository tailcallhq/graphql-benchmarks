package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"sync"
	"time"

	"example.com/gqlgen-users/graph/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/vikstrous/dataloadgen"
)

func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	resp, err := fetchFromJSONPlaceholder("/users")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var users []*model.User
	if err := decodeResponse(resp, &users); err != nil {
		return nil, err
	}

	return users, nil
}

func batchUsers(ctx context.Context, keys []string) (results []*model.User, errors []error) {
	var wg sync.WaitGroup
	var mu sync.Mutex
	wg.Add(len(keys))

	for _, key := range keys {
		go func(key string) {
			defer wg.Done()
			resp, err := fetchFromJSONPlaceholder(fmt.Sprintf("/users/%s", key))
			if err != nil {
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}
			defer resp.Body.Close()

			var user model.User
			if err := decodeResponse(resp, &user); err != nil {
				mu.Lock()
				errors = append(errors, err)
				mu.Unlock()
				return
			}

			mu.Lock()
			results = append(results, &user)
			mu.Unlock()
		}(key)
	}
	wg.Wait()
	return results, errors
}

func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	resp, err := fetchFromJSONPlaceholder("/posts")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var posts []*model.Post
	if err := decodeResponse(resp, &posts); err != nil {
		return nil, err
	}

	fields := graphql.CollectAllFields(ctx)

	for _, field := range fields {
		if field == "user" {
			var wg sync.WaitGroup
			wg.Add(len(posts))
			var userLoader = dataloadgen.NewLoader(batchUsers, dataloadgen.WithWait(time.Millisecond))
			for _, post := range posts {
				go func(post *model.Post) {
					defer wg.Done()
					user, err := userLoader.Load(ctx, fmt.Sprintf("%d", post.UserID))
					if err != nil {
						return
					}
					post.User = user
				}(post)
			}
			wg.Wait()
			break
		}
	}

	return posts, nil
}

func (r *userResolver) Posts(ctx context.Context, obj *model.User) ([]*model.Post, error) {
	resp, err := fetchFromJSONPlaceholder(fmt.Sprintf("/users/%d/posts", obj.ID))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var posts []*model.Post
	if err := decodeResponse(resp, &posts); err != nil {
		return nil, err
	}

	return posts, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

var proxyURL = &url.URL{
	Scheme: "http", // or "https" if your proxy is using HTTPS
	Host:   "127.0.0.1:3000",
}
var client = &http.Client{
	Transport: &http.Transport{
		Proxy:               http.ProxyURL(proxyURL),
		MaxIdleConns:        1000, // Set the total max idle connections
		MaxIdleConnsPerHost: 200,  // Set the max idle connections per host
		IdleConnTimeout:     30 * time.Second,
	},
}

func fetchFromJSONPlaceholder(endpoint string) (*http.Response, error) {
	req, err := http.NewRequest("GET", "http://jsonplaceholder.typicode.com"+endpoint, nil)
	if err != nil {
		return nil, err
	}
	return client.Do(req)
}
func decodeResponse(resp *http.Response, v interface{}) error {
	// Use a buffered reader to optimize JSON decoding
	reader := bufio.NewReader(resp.Body)
	return json.NewDecoder(reader).Decode(v)
}
